SOLID:SRP противоречит GRASP:Polymorphism, потому, что полиморфизм размывает ответственность, рассредоточивая ее по цепочке наследников, а SRP концентрирует. Вообще полипорфизм я признаю только на 1 уровень: интерфейс или абстрактный класс (что хуже) и от них 1 уровень классов наследников. Если больше, то можно запутаться и лучше делать композицию или агрегацию. Они даже друг-другу противоречат, например, GRASP: Indirection частично противоречит GRASP: High Cohesion, иногда нам нужно понизать Cohesion, а иногда повышать, зависит от конкретного случая и интуиции инженера. GRASP Information Expert частично противоречит GRASP: Pure Fabrication. Это все вопрос баланса

### GRASP
**General Responsibility Assignment Software Patterns**

---

5:03 - **Information Expert**

**Проблема**: как распределить ответственность между классами (в общем случае - между любыми абстракциями)?

**Решение**: назначить ответственность классу, который имеет всю необходимую информацию для работы (принятия решений)

**Зачем**: снижает зацепление (coupling), упрощает код, повышает инкапсуляцию, переиспользование

**О чем говорит принцип**: у нас есть некая абстракция, с внутренними полями, методами, логикой и не надо в нее лезть, он сам с ней разберется - у него есть для этого вся информация. И нужно с этой абстракцией работать через внешний интерфейс

---

13:06 - **Creator**

**Проблема**: кто должен создавать инстанс? кто держит ссылку или разрушает? 

**Решение**: тот, кто содержит или агрегирует инстансы, кто интенсивно работает с ними, кто имеет информацию для инициализации. Также в этом же месте мы держим ссылку на абстракцию и потом разрушаем ее (где выделилась память, там она и должна быть освобождена).   

**Зачем**: для снижения зацепления

**Примеры:** конструктор, фабрика, пул

---

18:15 - **Cohesion & Coupling**

- **Coupling** - зацепление между классами, модулями, абстракциями
- **Cohesion** - связанность внутри класса, модуля, компонента, любой абстракции 

---

21:33 - **Controller**

Точка входа для внешнего взаимодействия (пользовательского интерфейса), выполняет системные операции (кэширование, валидация, логирование и т.п.) и делегирует бизнес-логику (она дальше должна быть максимально линейной)

**Проблема**: кто и как взаимодействет с UI? 

**Зачем**: защита от событий, конкурентности, асинхронности, параллельности

**Примеры**: команда, фасад, изоляция слоев

---

24:58 - **Polymorphism**

Альтернативное поведение на основании типа (см. SOLID: LSP, OCP) 

**Проблема**: как быть если в зависимости от типа надо изменять поведение?

**Решение**: заменяем if и case на полиморфизм и наследование, обращаемся через интерфейс или абстрактный класс. 

**Как реализовать**: если много каких-то if / case в зависимости от типов - делаем программную абстракцию (интерфейс, абстрактный класс) и делаем от нее много наследников в которых разная имплементация какого-то метода. И в зависимости от типа инстанса на котором мы этот метод вызываем, меняется поведение.

**Связь с SOLID**:
- LSP - например, к нам в конструктор приходит инстанс который наследуется от интерфейса и мы не знаем какая именно реализация пришла в конкретном наследнике, но мы можем работать с ним как с базовым классом, т.к. во всех реализациях сигнатура этого метода одинаковая
- OCP - мы не можем нарушать контракт интерфейса, но в конкретной реализации можем его расширять  

---

31:55 - **Indirection** (Посредник)

Введение объекта-посредника снижает зацепление между абстракциями.

**Зачем**: снижает зацепление, улучшает переиспользование кода

**Примеры**: шаблон Mediator (посредник) из GoF, в шаблоне VMC - C (контроллер)  

---

34:34 - **Pure Fabrication**

Абстракция, которой нет в предметной области. Она часто позволяет снизить зацепление классов предметной области.

**Примеры**: Socket, DN Query, Event Emitter, Promise, список, асинхронная очередь.

---

38:36 - **Protected Variations**

Защита абстракций от изменений путем спецификации интерфейсов или контрактов и взаимодействию через них.
