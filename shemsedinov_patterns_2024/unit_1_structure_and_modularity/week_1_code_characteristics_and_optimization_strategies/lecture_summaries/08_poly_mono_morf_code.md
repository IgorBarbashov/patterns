### Мономорфный и полиморфный код, инлайн-кэш, скрытые классы в JavaScript

---

- 0:43 поля
- 6:27 скрытые классы
- 10:28 инлайн кэш
- 14:50 метод
- 18:47 оптимизация кода для массивов
- 35:46 инлайн кэш в массивах
- 42:40 примеры с функциями
- 50:40 примеры с глобальными свойствами
- 57:18 итоги
- 1:01:30 вопрос про скрытые классы
- 1:05:40 вопрос про оптимизацию

---

**Inline-cash** - это шаблоны машинного кода, которые хранятся у оптимизирующего компилятора и он по типам их подбирает.

Т.е. если он видит что в конкретном месте идет всегда обращение к одной и той же форме, то он подбирает этот `inline-cash` и заменяет в этом месте неоптимизированный байт-код на оптимизированный байт-код.

---

1. Например есть функция
```js
const getX = obj => obj.x;
```

В начале мы не знаем как и где (по какому смещению) находится поле `x` относительно начала объекта. Какого оно типа и т.п.

После первых вызовов, например:
```js
getX({ x: 10 }) // { x: number }
getX({ x: 70 }) // { x: number }
```
знания об этих вызовах и о том откуда и как брать `x` хранятся и накапливаются в `inline-cash` 

Информация о формах объектов переданных аргументов накапливаются в `inline-cash` внутри конкретной функции.

В этой функции, наверное, будет два таких кэша:
- первый по обращению к полю `x`
- второй - по возвращению результата который возвращает функция

Если мы передадим этот же объект в другую функцию, там будут свои `inline-cash` и свои оптимизации.

2. Если мы вызовем функцию с объектом другой формы в качестве аргумента:
```js
getX({ x: 10, y: 20 }); // { x: number; y: number }
getX({ y: 20, x: 10 }); // { y: number; x: number }
```
Получается `полиморфное` обращение к полю `x`. Т.е. искать его можно по смещению, которое запомнилось в `inline-cash` при первой операции, а можно по смещению, которое запомнилось при второй операции.

**Т.о. для оптимизаций компилятора очень важны в какой форме используется объект, с какими скрытыми классами он связывается, какую цепочку модификаций он проходит от создания до использования.**

**Объекты, которые проходят одну и ту же цепочку модификаций, связываются с одними и теми же внутренними классами и компилятор использует ранее накопленную информацию по обращению к полям объекта при его последующем использовании.**

Пока обращение к полю объекта внутри функции было связано с одной формой объекта - это было мономорфное состояние кэша. Когда мы повызывали с другой формой - стало полиморфным. И в итоге когда таких форм накапливается много - состояние кэша становится мегаморфным, которое используется уже для всего runtime (глобальная таблица форм).    

---

То же самое с элементами массива

---

[42:42] - Пример оптимизации выполнения функции с моно-/полиморфным кодом и деоптимизации при мегаморфном коде.

---

**Выводы**:
- если писать на JS как будто это язык с типами, он будет разгоняться за счет работы оптимизирующего компилятора
- механизм "разгона" JS - это сначала механизм интерпретации; потом он по типам пытается догадаться какие можно взять оптимизации, создает `inline-cash`
- лучше всего работает мономорфный код, когда в одном месте используется одна и та же форма
- если не будет найдено подходящего `inline-cash`, то код возвращается на интерпретацию и тогда такой код не оптимизируется и будет работать дольше всего